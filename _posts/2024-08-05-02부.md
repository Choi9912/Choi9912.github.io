---
title: 클린 아키턱처 02부 벽돌부터 시작하기
date: 2024-08-05 14:10:00 +0800
author: cotes
categories: [Blogging , 클린 아키텍처 ]
tags: [클린 아키텍처 , 클린 코드  ]
render_with_liquid: false
---

# 03장 패러다임 개요

## 구조적 프로그래밍
- 최초로 적용된 패러다임
- 데이크스트라는 무분별한 점프(goto 문장)는 프로그램 구조에 해롭다는 사실 제시
- 구조적 프로그래밍은 제어흐름의 직접적인 전환에 대한 규칙 부과.

## 객체 지향 프로그래밍
- 함수 호출 스택 프레임을 힙으로 옮기면, 함수 호출이 반한된 이후에도 함수에서 선언된 지역변수가 오랫동안 유지 될 수 있음을 발견  -> 클래스의 생성자 ,지역변수는 인스턴스 변수 , 중첩 함수는 메서드
- 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙 부과.

## 함수형 프로그래밍
- 람다 계산법을 발명
- 람다 계산법의 기초가 되는 개념은 불변성으로 심볼의 값이 변경되지 않는다는 개념
- 함수형 프로그래밍은 할당문에 대해 규칙 부과

## 생각할 거리
- 패러다임은 무엇을 해야할지를 말하기보다는 무엇을 해서는 안 되는지 말해줌

# 04장 구조적 프로그래밍

## 증명
- 다익스트라는 goto 문이 모듈 분해를 방해한다고 발견했지만, 간단한 제어 구조(if/then/else, do/while)만으로 프로그램을 증명 가능한 단위로 분해할 수 있음을 확인함.
-뵘과 야코피니는 2년 전에 프로그램이 순차, 분기, 반복의 3가지 구조로 표현 가능하다고 증명함.

## 해로운 성명서
- 다익스트라는 1968년 “goto문의 해로움”을 주장하며 논쟁을 일으켰고, 결과적으로 goto 문은 대부분의 현대 언어에서 사라짐.
- 현재 대부분의 언어는 goto 문을 지원하지 않으며, 우리는 구조적 프로그래밍을 강제당하고 있음.

## 기능적 분해
- 구조적 프로그래밍을 통해 문제를 고수준에서 저수준의 함수로 기능적으로 분해할 수 있음.
- 이러한 기능적 분해는 구조적 프로그래밍의 제한된 제어 구조를 이용하여 표현 가능함.
- 이로 인해 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 이는 입증 가능한 작은 기능들로 세분화 가능함.

## 테스트
- 다익스트라는 "테스트는 버그의 존재를 보여줄 뿐, 버그가 없음을 증명할 수는 없다"고 말함.
테스트는 프로그램이 목표에 부합할 만큼 충분히 참이라는 것을 확인할 수 있음.

## 결론
- 구조적 프로그래밍의 가치는 반증 가능한 단위를 만들어내는 능력에 있음.
- 현대적 언어가 goto를 지원하지 않는 이유도 여기에 있음.
- 기능적 분해는 소프트웨어 아키텍처의 최고 실천법 중 하나이며, 이는 소프트웨어의 테스트 용이성을 높임.
- 좋은 아키텍처는 테스트하기 쉬워야 하며, 이는 반증 가능성이 높아야 함을 의미함.

# 05장 객체 지향 프로그래밍

## 서론
- 객체 지향 설계(OO)는 좋은 아키텍처의 시작점이며, 종종 "데이터와 함수의 조합"으로 설명되지만, 이는 OO의 본질을 충분히 설명하지 못함.
- OO의 목적은 현실 세계를 모델링하는 것이라 하지만, 이는 의미가 불분명하고 모호함.
- 캡슐화, 상속, 다형성으로 OO를 설명하기도 하나, 이 역시 OO의 본질을 완벽히 설명하지 못함.

## 캡슐화
- OO 언어는 데이터와 함수를 캡슐화하는 방법을 제공하지만, 이는 OO 언어가 아닌 언어에서도 가능함.
- 실제로 많은 OO 언어는 캡슐화를 강제하지 않고, 프로그래머의 신뢰에 의존함.
- OO 언어에서 캡슐화는 잘 지켜지지 않는 경우가 많음.

## 상속
- OO 언어는 상속을 제공하지만, 이는 단순히 변수와 함수를 유효 범위 내에서 재정의하는 것에 불과함.
- 상속을 구현하는 다른 방법도 있었으나, OO가 이를 더 편리하게 함.
- 상속에 대한 점수는 0.5점 정도로 미미함.

## 다형성
- 다형성은 함수 포인터를 응용한 것으로, OO가 새롭게 만든 개념은 아님.
- 다형성은 OO 언어에서 더 안전하고 편리하게 사용 가능함.
- OO 언어는 다형성을 쉽게 사용하게 해주어 제어 흐름을 간접적으로 전환하는 규칙을 부과함.

## 다형성이 가진 힘
- 이전에는 함수 포인터 사용의 위험성 때문에 다형성을 적용하기 어려웠으나, OO의 등장으로 다형성을 쉽게 사용할 수 있게 됨.
- 다형성 덕분에 플러그인 아키텍처를 쉽게 적용할 수 있게 됨.

## 의존성 역전
- 다형성 등장 이전: 소스 코드 의존성은 제어 흐름을 따라야 했음.
- 다형성 등장 이후: 인터페이스를 통해 소스 코드 의존성을 제어 흐름과 반대로 설정할 수 있음. 이를 의존성 역전이라 함.

## 배포 및 개발 독립성
- 각 컴포넌트는 독립적으로 컴파일, 배포, 개발 가능함.
- 특정 컴포넌트 변경 시 해당 컴포넌트만 다시 배포하면 됨.

## 기존 아키텍처와 다형성
- 다형성이 없는 계층형 아키텍처는 데이터베이스 중심.
- 인터페이스 도입 시 서비스 중심으로 전환 가능.
- 다형성 덕분에 의존성 방향을 제어할 수 있음.

## 결론
- OO의 핵심은 다형성을 통해 의존성 방향을 제어하는 능력임.
- 이를 통해 고수준 모듈과 저수준 모듈의 독립적 개발 및 배포 가능.

# 06장 함수형 프로그래밍

## 정수를 제곱하기
- 함수형 프로그래밍에서는 가변 변수가 없으며, 한번 초기화된 변수는 변하지 않음.

## 불변성과 아키텍처
- 경합 조건, 교착 상태, 동시 갱신 문제는 모두 가변 변수로 인해 발생함.
- 불변 변수 사용 시 동시성 문제가 발생하지 않음.
- 자원이 제한적이므로 불변성과 가변성을 적절히 타협해야 함.

## 가변성의 분리
- 가변 컴포넌트와 불변 컴포넌트를 분리해야 함.
- 불변 컴포넌트는 함수형 방식으로 처리, 가변 컴포넌트는 트랜잭션 메모리 등으로 보호.
- 가능한 많은 처리를 불변 컴포넌트로 옮기는 것이 중요함.

## 이벤트 소싱
- 상태 대신 트랜잭션을 저장하여 가변 변수 필요성을 제거.
- 모든 트랜잭션을 처리해 상태를 재구성, 저장 공간과 처리 능력의 한계가 있음.
- 주기적으로 상태를 계산해 저장하면 효율적임.

## 결론
- 3가지 프로그래밍 패러다임:
    - 구조적 프로그래밍: 제어 흐름의 직접적 전환 규율.
    - 객체 지향 프로그래밍: 제어 흐름의 간접적 전환 규율
    - 함수형 프로그래밍: 변수 할당에 대한 규율.
- 세 패러다임은 코드 작성 방식을 제한하며, 핵심은 여전히 순차, 분기, 반복, 참조에 있음.

## 정리
각 패러다임은 프로그래밍을 위한 특정 규칙이나 원칙을 제공하지만, 결국 모든 프로그램은 이러한 기본적인 요소를 사용하여 구성됩니다. 즉, 구조적, 객체 지향, 함수형 프로그래밍의 규칙은 제어 흐름을 다루는 방식을 달리하더라도, 프로그램의 기본적인 작동 방식인 순차 실행, 분기, 반복, 참조의 원리를 바탕으로 합니다.

각 패러다임은 이러한 기본 요소를 조합하여 코드의 품질, 유지 보수성, 재사용성을 향상시키는 데 중점을 두고 있지만, 프로그램의 근본적인 작동 방식은 여전히 동일합니다.
