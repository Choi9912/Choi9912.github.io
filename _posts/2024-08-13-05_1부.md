---
title: 클린 아키턱처 05부_1 아키텍처
date: 2024-08-13 14:10:00 +0800
author: cotes
categories: [Blogging , 클린 아키텍처 ]
tags: [클린 아키텍처 , 클린 코드 ]
render_with_liquid: false
---

# 15장 아키텍처란?

## 서론
소프트웨어 시스템의 아키텍처는 시스템을 구성하는 컴포넌트의 분할, 배치, 그리고 이들 간의 의사소통 방식을 통해 시스템의 형태를 정의합니다. 이러한 아키텍처는 시스템의 개발, 배포, 운영, 유지보수를 용이하게 하며, 가능한 많은 선택지를 가능한 오랫동안 열어두는 전략을 중요하게 여깁니다.

## 선택사항 열어두기
아키텍처의 주요 목표는 시스템을 올바르게 동작하게 하는 것뿐만 아니라 시스템의 생명주기를 지원하고, 이를 통해 비용을 최소화하고 프로그래머의 생산성을 극대화하는 것입니다.

아키텍처는 정책과 세부사항으로 분리될 수 있습니다. 정책은 시스템의 핵심 가치와 업무 규칙을 나타내며, 세부사항은 정책과의 소통을 위한 요소들(입출력 장치, 데이터베이스, 웹 시스템 등)을 포함합니다. 좋은 아키텍트는 정책을 세부사항과 분리하고, 가능한 한 세부사항에 대한 결정을 미루는 방식으로 설계를 진행합니다.

# 16장 독립성

## 서론
- 좋은 소프트웨어 아키텍처는 유스케이스, 운영, 개발, 배포를 지원해야 합니다.

## 유스케이스
- 아키텍처는 시스템의 목적을 반영하는 유스케이스를 명확히 지원해야 하며, 최상위 수준에서 그 의도를 쉽게 파악할 수 있어야 합니다.

## 운영
- 운영 관점에서는 실질적 요구사항(예: 초당 10만 명 처리)을 충족할 수 있도록 아키텍처를 구성해야 합니다.

## 개발
- 아키텍처는 개발 환경을 지원해야 하며, 콘웨이의 법칙을 고려해 조직의 의사소통 구조에 맞는 독립적이고 격리된 컴포넌트를 만들 수 있어야 합니다.

## 배포
- 아키텍처는 즉각적인 배포가 가능하도록 지원해야 하며, 시스템을 적절하게 분할하고 격리하여 쉽게 배포할 수 있어야 합니다.

## 중복
- 중복은 나쁜 것이지만, 중복이 진짜인지 가짜인지 구분한 후 제거해야 합니다.

## 결합 분리
- 소스 수준 분리: 모듈 간 의존성을 제어하여, 변경 시 다른 모듈에 영향을 주지 않도록 함.
- 배포 수준 분리: 배포 가능한 단위 간 의존성을 제어하여 독립적인 재빌드 및 재배포가 가능하게 함.
- 서비스 수준 분리: 마이크로서비스와 같이 완전한 독립성과 네트워크 기반 통신을 통해 실행 단위들을 분리함.

# 17장 경계: 선 긋기

## 서론
- 경계는 소프트웨어 요소들을 분리하고, 한쪽 요소가 다른 쪽 요소를 알지 못하도록 차단하는 역할을 합니다.
- 아키텍트의 목표는 결합을 줄여 인적 자원의 효율성을 극대화하는 것입니다. 이른 결정, 특히 업무 요구사항과 무관한 결정이 결합을 초래합니다.

## 플러그인 아키텍처
- 소프트웨어 개발 기술의 역사는 플러그인을 쉽게 생성하여 확장 가능하고 유지보수하기 쉬운 아키텍처를 만드는 방법을 다룹니다. 
- 핵심 업무 규칙은 다른 컴포넌트로부터 분리되어 독립적이어야 하며, 이 컴포넌트들은 플러그인 형태로 고려됩니다.
- 기술의 교체가 쉬운 일은 아니지만, 플러그인 구조를 적용하면 이를 현실적으로 가능하게 합니다.

## 결론
- 소프트웨어 아키텍처에서 경계를 설정하기 위해서는 시스템을 컴포넌트 단위로 분할해야 합니다. 
- 일부는 핵심 업무 규칙을 포함하고, 나머지는 플러그인으로 필수 기능을 담당합니다. 
- 컴포넌트 간 의존성은 저수준 세부사항에서 고수준의 추상화를 향하도록 배치되어야 합니다.

# 19장 정책과 수준

## 서론 
- 소프트웨어 시스템은 정책을 기술한 것으로, 하나의 정책은 여러 작은 정책으로 나눌 수 있습니다
- 동일한 이유로 동일한 시점에 변경되는 정책들은 같은 컴포넌트에 속해야 하며, 서로 다른 이유로 변경되는 정책은 반드시 분리된 컴포넌트에 위치해야 합니다.

## 수준
- 수준은 시스템의 입력과 출력으로부터의 거리를 의미합니다.
- 고수준 정책: 입력과 출력으로부터 멀리 위치하며, 덜 빈번하게 변경되지만 더 중요한 이유로 변경됩니다.
- 저수준 정책: 입력과 출력을 다루며, 빈번하게 변경되지만 덜 중요한 이유로 변경됩니다.

## 결론
- 단일 책임 원칙(SRP)과 공통 폐쇄 원칙(CCP)에 따라 동일한 시점에 동일한 이유로 변경되는 정책은 함께 묶여야 합니다. 
- 모든 소스 코드 의존성을 고수준 정책에 맞추면, 저수준의 변경이 고수준에 미치는 영향을 최소화할 수 있습니다.

# 20장 업무 규칙

## 서론
- 업무 규칙: 사업에서 수익을 얻거나 비용을 줄이는 규칙으로, 컴퓨터 시스템에서 자동화되었는지 여부와 상관없이 존재함.
- 핵심 업무 규칙: 사업에 핵심적인 규칙으로, 이 규칙을 자동화하지 않더라도 중요함.
- 핵심 업무 데이터: 핵심 업무 규칙에 필요한 데이터로, 이 데이터와 규칙을 결합한 객체를 엔티티라고 부름.

## 엔티티
- 엔티티: 핵심 업무 규칙과 데이터를 객체로 표현한 것으로, 업무에 특화된 비즈니스 로직을 담고 있음.
- 독립성: 엔티티는 DB, UI, 프레임워크에 의존하지 않으며, 순수한 비즈니스 로직에 집중함.
- 풍부한 도메인 객체: 메서지를 갖고 있는 객체로, 테스트와 유지보수가 쉬움.

## 유스케이스
- 유스케이스: 시스템이 어떻게 동작하는지를 정의하며, 엔티티 내부의 규칙을 언제, 어떻게 호출할지 명시함.
- 의존성 방향: 유스케이스는 엔티티에 의존하지만, 엔티티는 유스케이스에 의존하지 않음. 유스케이스는 특정 애플리케이션에 특화된 규칙을 다룸.

## 요청 및 응답 모델
- 독립성: 유스케이스는 HTML이나 SQL 같은 기술에 의존하지 않아야 하며, 요청 및 응답 모델과도 분리되어야 함.
- SRP와 CCP 준수: 엔티티와 요청/응답 모델은 목적이 다르기 때문에, 둘을 분리하여 유지하는 것이 중요함.

# 21장 소리치는 아키텍처

## 아키텍처의 테마
- 아키텍처는 프레임워크에 대한 것이 아니며, 프레임워크는 사용하는 도구일 뿐임

## 아키텍처의 목적
- 좋은 아키텍처는 프레임워크, 데이터베이스, 웹 서버, 여타 개발 환경 문제나 도구에 대한 결정 미룰 수 있음
- 좋은 아키텍처는 유스케이스에 중점을 두며, 지엽적인 관심사에 대한 결합 분리시킴

## 하지만 웹은?
- 웹은 전달 메커니즘이며, 아키텍처에서도 그와 같이 다뤄야 함
- 애플리케이션이 웹으로 전달된다는 사실은 세부 사항이며, 시스템 구조를 지배해서는 절대 안됨

## 프레임워크는 도구일 뿐, 삶의 방식이 아니다
- 프레임워크가 모든 것을 하게 하자 라는 태도를 취하지만 이는 우리가 취하고 싶은 태도가 아님
- 우리는 어떻게 하면 아키텍처를 유스케이스에 중점을 둔 채 그대로 보존할 수 있을지 생각해야함

## 테스트하기 쉬운 아키텍처
- 아키텍처가 유스케이스를 최우선으로 한다면, 프레임워크 없이도 필요한 유스케이스 전부를 단위 테스트 할 수 있어야함.
- 엔티티는 반드시 POJO(Plain Old Java Object)여야 하며, 프레임워크나 데이터베이스 및 다른 것들에 의존해서는 안되고 유스케이스가 엔티티를 조작해야 함.

## 결론
- 아키텍처는 시스템을 이야기해야 하며, 시스템에 적용된 프레임워크에 대해 얘기해서는 안됨
- 시스템이 어떻게 전달될 지 알지 못한 상태에서도 시스템의 모든 유스케이스를 이해할 수 있어야 

