---
title: 클린 아키턱처 03부 설계 원칙
date: 2024-08-07 14:10:00 +0800
author: cotes
categories: [Blogging , 클린 아키텍처 ]
tags: [클린 아키텍처 , 클린 코드 ]
render_with_liquid: false
---

# 07장 SRP : 단일 책임 원칙

## 서론
- SOLID 원칙 중에서 그 의미가 가장 전달되지 못한 원칙으로, 하나의 일만 해야한다는 의미가 아님
- SRP는 "단일 모듈은 변경의 이유가 하나, 오직 하나뿐이여야 한다."는 원칙임
- 여기서 변경의 이유는 하나의 액터에 해당함
- 즉, 최종적으로 "하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임을 져야 한다."는 원칙임

## 징후 1 :우발적 중복
- 코드베이스에서 같은 기능을 여러 곳에서 반복적으로 구현하는 것을 의미
- 주요 포인트
    - 중복 코드
    - 변경의 일관성
    - 유지보수 비용 증가

## 징후 2 : 병합
- 소스 파일에 다양하고 많은 메소드를 포함하면 병합이 발생하기 쉬운데, 서로 다른 액터를 책임진다면 그 가능성이 더 높음
- 변경사항은 서로 충돌하고 결과적으로 병합이 발생하는데 항상 위험이 따름
- 문제를 벗어나는 방법은 서로 다른 액터를 뒷받침하는 코드를 서로 분리하는 것

## 해결책
- 메소드를 서로 다른 클래스로 이동시키는 방식
- 가장 확실한 방법은 데이터와 메소드를 분리
    - 자료구조 클래스를 만들어 3가지 클래스가 공유하고, 각 클래스는 반드시 필요한 소스 코드만을 포함
    - 서로의 존재를 모르게 함으로써 "우연한 중복"을 피함
    - 하지만 이는 개발자가 3가지 클래스를 객체로 만들고 추적

## 결론
여기서 "책임"이 중요합니다.
SRP는 단지 클래스에 한정된것도 아니고 어떤 코드 모둠별로(클래스 뿐만아니라 함수, 모듈 등등이 될 수 있음) 하나의 책임만이 있어야 한다는뜻</BR>
예를 들어보자면 유저라는 클래스 안에 사용자 인증/사용자 비밀번호 변경/탈퇴 등의 메서드가 모두 안에 있다면 각 기능을 수정하거나 확장할때 다른 기능들에 영향을 주게 될 수도 있음

# 08장 OCP : 개방 폐쇄 원칙

## 서론
- OCP는 “소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.”는 원칙임
- 즉, 행위를 확장할 수 있어야 하지만 개체를 변경해서는 안되며, 이것이 아키텍처를 공부하는 근본적인 이유임 
- OCP는 클래스와 모듈 설계에 도움이 되는 원칙으로만 알고 있지만, 아키텍처 컴포넌트 수준에서 OCP는 훨씬 중요한 의미를 가짐

## 사고 실험
- 핵심 개념
    - 변경 최소화 : 훌륭한 소프트웨어 아키텍처는 변경되는 코드의 양을 최소화, 이상적으로는 0으로 만듦
    - 책임 분리(SRP) : 서로 다른 목적으로 변경되는 요소 분리 
    - 의존성 체계화(DIP) : 요소 간 의존성을 체계적으로 구성
- 예시
    - 보고서 생성 시스템 : 웹과 프린터로 보고서를 생성하는 두 가지 책임 분리
    - 변경 관리 : 한 책임에 변경이 생겨도 다른 책임에 영향을 주지 않도록 소스 코드 의존성을 조직화

- 컴포넌트 구분
    - 클래스 분할: 처리 과정을 클래스 단위로 분할.
    - 컴포넌트 단위: 클래스를 이중선으로 표시된 컴포넌트 단위로 구분.
- 의존성 관리
    - 단방향 관계: 모든 컴포넌트 관계는 단방향.
    - 보호 방향: 화살표는 변경으로부터 보호하려는 컴포넌트를 향함.
        - 예시: A의 변경으로부터 B를 보호하려면 A가 B에 의존함 (A -> B).
- Interactor 보호
    - 변경 보호: Presenter에서 발생한 변경으로부터 Controller를 보호.
    - 독립적 Interactor: 다른 모든 변경으로부터 영향을 받지 않음.
    - OCP 준수: Interactor는 비즈니스 로직을 포함하며, 개방-폐쇄 원칙(OCP)을 가장 잘 준수함.

## 방향성 제어
- 인터페이스의 용도는 의존성을 역전시키기 위함
- 이는 헥사고날 아키텍처의 포트로 이어짐

## 정보 은닉
- 

## 결론
- OCP는 시스템의 아키텍처를 떠받치는 원동력 중 하나
- 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는데 있음
- 이를 위해 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트의 변경으로부터 고수준 컴포넌트를 보호할 수 있는 구조가 되어야 함

# 09장 LSP : 리스코프 치환 원칙

## 서론 
-  S 타입의 객체 o1 각각에 대응하는 T 타입 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위 타입이다."

## LSP와 아키텍처
- 객체 지향이 등장한 초창기에 LSP는 상속을 사용하도록 가이드하는 방법 정도로 간주됨
- 하지만 시간이 지나면서 LSP는 인터페이스와 구현체에도 적용되는 광범위한 소프트웨어 설계 원칙으로 변모해왔음
- 아키텍처 관점에서 LSP를 이해하는 최선의 방법은 이 원칙을 어겼을 때 시스템 아키텍처에 무슨 일이 일어나는지 관찰하는 것

## LSP 위배사례
- 아키텍트는 버그로부터 시스템을 격리
- EX) 택시 파견 서비스를 통합하는 애플리케이션을 만드는 상황
    - A 택시 회사의 택시 파견 URI는 aaa.com/driver/Bob/pickupAddress/24/pickupTime/153/**destination**/ORD
    - 새로운 팀이 B 택시 회사 파견 URI를 일부 다르게 설계함 ex) destination -> dest
    - REST 서비스들이 서로 호환되지 않음
    - 아키텍처에서는 if로 분기 처리가 아니라, 치환되지 않는 REST 서비스들의 인터페이스를 처리하는 매커니즘이 필요함

## 결론
- LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야함
- 치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 매커니즘을 추가해야 할 수 있기 때문

# 10장 ISP : 인터페이스 분리 원칙

## 서론
![image-1](https://github.com/user-attachments/assets/525d6230-7237-4695-99e5-e02d17eaa6d8)

- USER1의 소스 코드는 U10ps와 Op1에는 의존하지만 OPS에는 의존 X
- 따라서 OPS에서 발생한 변경이 USER1과 관계없다면 USER1을 다시 컴파일하고 새로 배포할 필요 없음

## ISP와 언어
- ISP는 아키텍처가 아니라 언어와 관련된 문제라고 결론내릴 여지가 잇음
- 정적 타입 언어(C, 자바)
    - import, use, include 같은 타입 선언문 사용 강제
    - 이로 인해 소스 코드 의존성 발생, 재컴파일 및 배포 강제되는 상황
- 동적 타입 언어(루비, Python)
    - 정적 타입 언어를 사용할 때보다 유연하며 결합도가 낮은 시스템 만들 수 있음

## ISP와 아키텍처
- 소스 코드 의존성의 경우에는 불필요한 재컴파일과 재배포를 강제
- 이는 더 고수준의 아키텍처 수준에서도 마찬가지
![image-2](https://github.com/user-attachments/assets/3d769b57-5d69-4c9f-b422-ee03367a7267)
- 시스템(S)를 구축중인 아키텍트가 프레임워크(F)를 도입하길 원하고, 개발자는 DB(D)를 반드시 사용하도록 만듦
- S는 F에 의존, F는 D에 의존하는 상황
- F에서는 불필요한 기능하며 S와는 전혀 관계없는 기능이 D에 포함된다고 할 때, 그 기능 때문에 D 내부가 변경되면 F를 재배포해야 할 수 있고 S까지 재배포해야 할 수 있음

## 결론
- 무언가를 의존하면 예상치 못한 문제에 빠짐

# 11장 DIP : 의존성 역전 원칙

## 서론
- 의존성이 극대화된 시스템이란 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템
- 하지만 소프트웨어 시스템이라면 구체적인 많은 장치에 반드시 의존하므로, 이를 규칙으로 보는 것은 비현실적
- 따라서 DIP를 논할 때 운영체제나 플랫폼과 같이 안정성이 보장된 환경에서 대해서는 무심
- 의존하지 않도록 피하고자 하는 것은 변동성이 큰 구체적인 요소임

## 안정된 추상화
 안정된 소프퉤어 아키텍처란 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스 선호하는 아키텍처
    - 변동성이 큰 구체 클래스는 참조하지 말라
    - 변동성이 큰 구체 클래스로부터 파생하지 말라
    - 구체 함수를 오버라이드 하지 말라
    - 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라

## 팩토리
- 규칙들을 준수하려면 변동성이 큰 구체적인 객체는 특별히 주의해서 생성해야함
- 객체를 생성하려면 해당 객체를 구체적으로 정의한 코드에 대해 소스 코드 의존성이 발생

## 구체 컴포넌트
- 구체 컴포넌트에는 구체적인 의존성이 하나 있고, 따라서 위배됨
- 대다수의 시스템은 이러한 구체 컴포넌트를 최소한 하나는 포함할 것이다.

## 결론
- DIP는 아키텍처 다이어그램에서 가장 눈에 드러나는 원칙
- 의존성은 이 곡선을 경계로, 더 추상적인 엔티티가 있는 쪽으로만 향함 = 의존성 규칙
