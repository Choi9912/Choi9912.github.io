---
title: HTTP
date: 2024-08-01 14:10:00 +0800
author: cotes
categories: [CS , HTTP ]
tags: [HTTP , 웹 , REST,]
render_with_liquid: false
---


# 웹이란?
## 웹과 인터넷
- 웹은 인터넷을 통해 정보를 공유하고 다양한 서비스를 이용할 수 있게 해주는 서비스
- 웹은 '웹 페이지'라고 불리는 문서들의 모음
- 웹 페이지는 하이퍼텍스트를 이용하여 연결, 하이퍼텍스트는 하이퍼링크, 링크를 포함되어있음

- 웹 페이지 중요 구성 요소
    - HTML : 구조와 내용 정의
    - CSS : 디자인과 레이아웃 정의
    - JavaScript : 웹 페이지 동적 구현
- 웹의 중요 구성 요소
    - URL : 웹 상의 자원 위치를 나타내는 주소
    - HTTP : 웹 브라우저와 웹 서버 간의 통신 규약
    - DNS : 도메인 이름을 IP 주소로 변환하는 시스템
    - 웹 서버 : 클라이언트의 요청을 받아 처리하고 응답 반환하는 서버
    - 웹 브라우저 : 사용자가 웹 페이지를 요청하고 받은 응답을 해석하여 보여주는 프로그램

## 웹의 동작
![image (1)](https://github.com/user-attachments/assets/716e4baa-febb-4fb6-98c6-2d4988aa20dd)
- 브라우저 주소 입력란에 URL을 입력하면 브라우저는 서버에게 해당 주소에 대한 리소스를 요청하고 웹 서버는 응답을 통해서 리소스를 전송.
- 이때 클라이언트가 서버를 찾아가려면 주소가 있어야 하는데, 그 주소는 DNS에 있음

## URI vs URL vs URN
- URI : 통합 자원 식별자</br>
EX)```urn:isbn:1234567890, http://example.com/page.html```
- URL : 리소스가 있는 위치 지정</br>
EX) ```http://example.com/page.html, ftp://example.com/file.zip```
- URN : 리소스에 이름 부여</br>
EX) ```urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6 ```(A유저의 UUID 예시)
![image-1 (1)](https://github.com/user-attachments/assets/e3d2df45-e5b2-48b9-bf02-c1dd22753030)

```python
from urllib.parse import urlparse
 
url = 'https://www.example.com/path/to/page?key1=value1&key2=value2#section'
parsed_url = urlparse(url)
 
print(parsed_url.scheme)  # "https"
print(parsed_url.netloc)  # "www.example.com"
print(parsed_url.path)    # "/path/to/page"
print(parsed_url.query)   # "key1=value1&key2=value2"
print(parsed_url.fragment)# "section"
```
# HTTP란?

## HTTP
하이퍼미디어 문서를 전송하기 위한 프로토콜
- 프로토콜 : 약속
    - 데이터가 전송되는 방식을 결정하는 규약
- HTTP 요청과 응답은 요청 또는 상태 라인 / 해더(생략가능) / 빈줄(해더의 끝) / 바디(생략가능) 의 형식을 따릅니다
    - 요청 라인: GET /index.html HTTP/1.1
    - 헤더: Host, User-Agent, Accept, Accept-Language, Accept-Encoding, Connection
    - 빈 줄: 헤더 다음의 빈 줄
    - 바디: 이 GET 요청에는 바디가 없습니다.


## Request
1. 요청라인 </br>
    a. 요청 메서드</br>
    b. 요청 페이지</br>
    c. 프로토콜 버전</br>
2. 헤더
    a. user-agent : 웹 브라우저 종류 및 버전정보</br>
    b. accept : 웹 브라우저가 처리할 수 있는 데이터 타입</br>
    c. cookie : http 프로토콜 자체가 세션을 유지하지 않는 접속상태를 유지하지 않는 방식이기에 로그인 인증을 위한 사용자 정보를 기억하려고 만든 인위적인 값</br>
    d. referer : 현재 페이지 접속 전에 어느 사이트를 경유했는지 알려주는 도메인</br>
    e. host : 사용자가 요청한 도메인 정보

## HTTP 메소드 설명

| 메소드   | 설명                                                                                  |
|----------|---------------------------------------------------------------------------------------|
| **GET**      | 리소스를 취득합니다. 쿼리 문자열을 URL에 추가하여 작은 값들을 전달할 때 사용됩니다.   |
| **POST**     | 리소스를 생성합니다. 데이터는 요청 본문(Body)에 포함되며, 상대적으로 큰 용량의 데이터를 전송할 때 사용됩니다. |
| **PUT**      | 리소스의 모든 내용을 업데이트합니다. 기존 리소스를 완전히 대체하며, 요청 본문(Body)에는 전체 리소스의 새 상태가 포함됩니다. |
| **DELETE**   | 리소스를 삭제합니다. 요청된 리소스를 서버에서 제거합니다.                            |
| **PATCH**    | 리소스의 일부를 업데이트합니다. 요청 본문(Body)에는 변경할 부분만 포함됩니다.        |
| HEAD     | HTTP 헤더 정보만 요청하며, 해당 자원의 존재 여부를 확인하는 목적입니다. GET과 비슷하지만 응답 본문(Body)은 반환하지 않습니다. |
| OPTIONS  | 웹 서버가 지원하는 메소드 종류를 반환합니다. 클라이언트가 서버의 기능을 확인할 때 사용됩니다. |
| TRACE    | 요청 리소스가 수신되는 경로를 확인합니다. 요청이 서버를 통해 어떻게 전달되는지 추적합니다. |
| CONNECT  | 요청 리소스에 대해 양방향 연결을 시작합니다. 주로 프록시 서버와의 터널링에 사용됩니다.    |

## Response
1. 상태 라인
    - HTTP: 버전
    - 상태 코드
    - 상태 메시지
2. 헤더
    - Server 
    - Content-Type
    - Content-Length
    - Date
3. 빈 줄
    - 헤더와 바디를 구분하는 빈 줄
4. 바디
    - 실제 응답 내용이 포함됩니다.


| 상태 코드 | 설명                                                                 |
|-----------|----------------------------------------------------------------------|
| **2xx**   | **성공**                                                                     |
| 200       | 서버가 요청을 제대로 처리.                                           |
| 201       | 성공적으로 요청되었으며 서버가 새 리소스를 작성.                     |
| 202       | 서버가 요청을 접수했지만 아직 처리하지 않음.                         |
| **3xx**   |           **리다이렉션**                                                           |
| 301       | 요청한 페이지를 새 위치로 영구적으로 이동.                           |
| **4xx**   |      **클라이언트 오류**                                                                |
| 400       | Bad Request. 잘못된 요청                                             |
| 401       | Unauthorized. 권한 없이 요청. Authorization 헤더가 잘못된 경우.      |
| 403       | Forbidden. 서버가 요청을 거부.                                       |
| 404       | 서버가 요청한 페이지를 찾을 수 없음.                                 |
| **5xx**   | **서버 오류**  |
| 500       | 서버에 오류가 발생하여 요청을 수행할 수 없음.                         |
| 503       | 서버가 오버로드되었거나 유지관리를 위해 다운되었기 때문에 현재 서버 사용 불가. |


## TCP/IP 4계층
TCP/IP는 인터넷 통신을 위한 기본 프로토콜 스위트(Protocol Suite, 프로토콜 모음)입니다. 이는 데이터를 패킷으로 나누어 전송하고, 수신 측에서 이를 받아 재조립하는 과정을 담당합니다.
- 정보를 감싸는 캡슐화를 통해 계층간 정보전달

- 송신 측
    1. 애플리케이션 계층 (편지 작성)
        - 긴 편지를 작성합니다. 이는 전송해야 할 큰 데이터를 나타냅니다.
    2. 트랜스포트 계층 (편지를 페이지로 나누기)
        - TCP: 편지를 일정한 크기의 페이지로 나눕니다. UDP보다는 느립니다. 신뢰성을 보장합니다.
        - UDP: 편지를 나누되, 페이지 크기가 일정하지 않을 수 있습니다. TCP보다는 빠릅니다. 신뢰성을 보장하지 않습니다.
    3. 인터넷 계층 (봉투에 넣어 주소 붙이기)
        - 각 페이지를 봉투에 넣고, 봉투에 받는 사람 주소 (IP 주소)를 씁니다.
    4. 네트워크 인터페이스 계층 (편지 발송)
        - 봉투를 우체국 (라우터)에 전달하여 발송합니다.

- 수신 측
    1. 네트워크 인터페이스 계층 (편지 수신)
        - 봉투를 받습니다.
    2. 인터넷 계층 (봉투에서 페이지 꺼내기)
        - 봉투를 열어 페이지를 꺼냅니다.
    3. 트랜스포트 계층 (페이지 재조립)
        - TCP: 페이지 번호 (시퀀스 번호)를 사용하여 페이지를 원래 순서대로 재조립합니다.
        - UDP: 페이지를 받은 순서대로 재조립합니다. 순서가 바뀌거나 페이지가 유실될 수 있습니다.
    4. 애플리케이션 계층 (편지 읽기)
        - 재조립된 편지를 읽습니다. 이는 수신된 데이터를 처리하는 것을 나타냅니다.

- 정보를 감싸는 캡슐화를 통해 계층간 정보 전달
![image-2 (1)](https://github.com/user-attachments/assets/2ecf7d93-ace9-4fca-b31c-3d24aa924af2)

- Response(응답)과 Request(요청) 과정
![image-3](https://github.com/user-attachments/assets/1ec211a8-1c1c-4418-bb45-65aa91d52b59)

## 클라이언트 상태 저장
### 쿠키 vs 로컬 스토리지
- 쿠키 
    - 자동 발송: 브라우저와 서버 간 자동 전송
    - 크기 제한: 보통 4KB 이하
    - 유형: 세션 쿠키(브라우저 종료 시 삭제), 영구 쿠키(만료 기간 후 삭제)
    - 퍼스트 파티 vs 서드 파티: 서비스 운영자가 발행(퍼스트 파티), 광고 등 외부에서 활용(서드 파티)
    - 사용자 조작 가능: 사용자 삭제/차단 가능, 중요한 정보는 서버에 저장 권장
    
- 로컬 스토리지
    - 수동 발송: 자동 전송되지 않음, 명시적 전송 필요
    - 저장 용량: 일반적으로 5MB 이상, 쿠키보다 많은 데이터 저장 가능
    - 사용자 조작 가능: 사용자 삭제/차단 가능, 중요한 데이터는 서버에 저장 권장
